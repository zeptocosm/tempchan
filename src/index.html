<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title id="htmlTitle">Tempchan : throwaway discussion boards</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŒ¸</text></svg>"/>
<style>
body {
	background-color: #eee;
	font-family: Tahoma, Helvetica, sans-serif;
}	
@keyframes fadeout {
	from {opacity: 1}
	to {opacity: 0}
}
body.fadeout {
	animation-name: fadeout;
	animation-duration: 20s;
	opacity: 0;
}

h1, #homePage>p, #myBoardsDiv, #myBoardsDiv *, #loadingPage *, #badLinkPage *, #incompleteLinkPage * {
	text-align: center;
}

button, label, input[type="checkbox"] {
	cursor: pointer;
}

#creationForm {
	max-width: min(100%, 720px);
	padding: 10px;
	padding-top: 0;
	border: 5px solid black;
	border-radius: 10px;
	background-color: white;
	margin-left: auto;
	margin-right: auto;
}
div.formValue {
	margin-bottom: 10px;
}
div.formValue:last-child {
	margin-bottom: 0;
}

.formValue div {
	display: inline-block;
}

.error {
	color: red;
}

#boardPage, #threadPage, #badLinkPage, #incompleteLinkPage {
	margin-left: 2%;
	margin-right: 2%;
	max-width: 960px;
}

.thread {
	border: 1px solid black;
	border-radius: 10px;
	padding: 5px;
	margin-top: 20px;
}
.thread.top {
	margin-top: 0;
}

#creationForm ul, #boardDescription {
	text-align: justify;
}

.post p {
	margin-left: 10px;
	margin-right: 10px;
	text-align: justify;
}
#fullThread .post {
	padding: 5px;
	border: 1px dotted transparent;
	border-radius: 10px;
}
#fullThread .post p:last-child {
	margin-bottom: 4px;
}
#fullThread .post.highlit {
	background-color: white;
	border-color: black;
}
#newPostContainer {
	margin-top: 5px;
}

.greentext {
	color: #090;
}
.woRedacted {
	color: #999;
}

.pagination {
	margin-top: 15px;
	margin-bottom: 15px;
}

#newBoardDescription {
	max-width: 100%;
}

.hidden {
	display: none !important;
}
.readOnly #newThreadContainer,
.readOnly #newPostContainer,
.readOnly .mentioner {
	display: none;
}

#myBoardsDiv h3 {
	display: inline;
}
#myBoardsDiv h3, #myBoardsList a {
	margin-right: 10px;
}
#myBoardsDiv sup {
	font-variant: small-caps;
}

.textareaContainer {
	display: inline-block;
	max-width: 100%;
}
.textareaContainer textarea {
	max-width: 98%;
}
.textareaContainer > div > div:nth-child(1) {
	float: left;
}
.textareaContainer > div > div:nth-child(2) {
	float: right;
}
.textareaContainer > div > div:nth-child(3) {
	clear: both;
}

#readOnlyMarker, #threadReadOnlyMarker, .writersOnlyMarker {
	font-variant: small-caps;
	line-height: 0;
	cursor: help;
	text-decoration: underline;
}
#readOnlyMarker, #threadReadOnlyMarker {
	display: none;
}
.readOnly #readOnlyMarker, .readOnly #threadReadOnlyMarker {
	display: inline;
}

#qrModalOuter {
	background-color: rgb(0,0,0);
	background-color: rgba(0,0,0,0.5);
	width: 100%;
	height: 100%;
	position: fixed;
	z-index: 1;
	left: 0;
	top: 0;
}
#qrModalInner {
	background-color: white;
	width: 200px;
	height: 200px;
	border: 5px solid black;
	border-radius: 10px;
	margin-left: auto;
	margin-right: auto;
	position: relative;
	top: 150px;
}
#qrCode {
	position: relative;
	top: 26px;
	transform-origin: top center;
}
#qrCode table {
	margin-left: auto;
	margin-right: auto;
}


</style>
</head>
<body>

<div id="loadingPage" class="hidden"><h2>Loading...</h2></div>

<div id="badLinkPage" class="hidden">
	<h2>Bad link!</h2>
	<p>The thing you're looking for doesn't exist, or has expired.</p>
	<p><a href="/">Back to home</a></p>
</div>

<div id="incompleteLinkPage" class="hidden">
	<h2>Incomplete link!</h2>
	<p>You've come here from an RSS feed for a board whose secret link is not in your history; therefore the board cannot be decrypted. Visit the board at its complete link (with <code>#</code> followed by 22&ndash;25 characters), and then reload this page.
	<p><a href="/">Back to home</a></p>
</div>

<div id="homePage">

<h1>ðŸŒ¸ Tempchan</h1>

<p><b>Tempchan</b> is a way of making anonymous, private, temporary discussion boards. <a href="/about.html">Learn more</a></p>

<p class="error" id="noscriptWarning">Tempchan requires JavaScript to run, in order to encrypt and decrypt messages in your web browser.</p>
<script>document.getElementById("noscriptWarning").style = "display:none";</script>

<div id="myBoardsDiv" class="hidden"><p>
<h3>My boards:</h3>
<span id="myBoardsList"></span>
<button onclick="clearMyBoards()">Clear</button>
</p></div>

<div id="creationForm">

<h2>Create a new board</h2>

<div>
<div class="formValue">
	<div><b>Title</b></div>
	<div>(max 100 characters)</div>
	<div><input type="text" placeholder="(Untitled)" id="newBoardTitle"/></div>
	<div class="error" id="titleError"></div>
</div>
<div class="formValue">
	<div><b>Description</b></div>
	<div>(max 1000 characters)</div>
	<div class="error" id="descriptionError"></div>
	<div style="display:block"><textarea cols="60" rows="3" placeholder="(optional)" id="newBoardDescription"></textarea></div>
</div>
<div class="formValue">
	<div><b>Lifespan (days)</b></div>
	<div>(max 35)</div>
	<div><input type="text" style="max-width:30px" id="newBoardLifespan"/></div>
	<div class="error" id="lifespanError"></div>
</div>

</div>

<ul>
	<li>Once the board is created, these settings cannot be changed. You will be taken to the board's <b>writeable link</b>, which you can share with others to invite them to post on it. Posts cannot be deleted once submitted.</li>
	<li>The board will also have a <b>read-only link</b>, which lets people read but not post.</li>
	<li>The board (and all of its posts) will be deleted at midnight (GMT) after the given lifespan has elapsed.</li>
</ul>

<button id="createBoardButton" onclick="createBoard()">Create board and take me there</button>

</div>

<hr/>
<p><a href="https://github.com/zeptocosm/tempchan" rel="noopener noreferrer" target="_blank">Source code</a> | Released under <a href="https://github.com/zeptocosm/tempchan/blob/main/LICENSE.txt" rel="noopener noreferrer" target="_blank">AGPLv3</a></p>

</div><!-- homePage -->


<div id="boardPage" class="hidden">

<h1><a href="#">Tempchan</a> | <span id="boardTitle"></span><sup id="readOnlyMarker" title="You are viewing this board via its read-only link; you can only post here if you have the writeable link.">ro</sup></h1>

<h3 style="text-align: center">Time till deletion: <span id="boardDeletionCountdown"></span><br/><a href="" onclick="showQR(); return false">QR</a> &middot; <a id="rssLink" href="" target="_blank" rel="noopener noreferrer">RSS</a><span id="otherAccessLinkSpan"> &middot; <a id="otherAccessLink" href=""></a></span></h3>

<div id="boardDescription"></div>

<div class="textareaContainer" id="newThreadContainer">
<textarea id="newThreadText" cols="60" rows="5"></textarea>
<div>
<div>
	<button id="newThreadButton" onclick="newThread()">Post new thread</button>
	<label><input type="checkbox" id="newThreadWo" />writers only</label>&nbsp;
</div>
<div><a href="/about.html#posting-guide" target="_blank">Help</a></div>
<div></div>
</div>
</div>

<hr/>

<div id="paginationTop" class="pagination"></div>

<div id="threadsView"></div>

<div id="paginationBottom" class="pagination"></div>

</div> <!-- boardPage -->


<div id="threadPage" class="hidden">

<h1><a href="#">Tempchan</a> | <a href="" id="threadBoardTitle"></a><sup id="threadReadOnlyMarker" title="You are viewing this board via its read-only link; you can only post here if you have the writeable link.">ro</sup> | <span id="threadHeader"></span></h1>

<h3 style="text-align: center">Time till deletion: <span id="threadDeletionCountdown"></span></h3>

<div id="fullThread"></div>

<div class="textareaContainer" id="newPostContainer">
<textarea id="replyText" cols="60" rows="5"></textarea>
<div>
<div>
	<button id="postReplyButton" onclick="postReply()">Reply</button>
	<label><input type="checkbox" id="postReplyWo" />writers only</label>&nbsp;
</div>
<div><a href="/about.html#posting-guide" target="_blank">Help</a></div>
<div></div>
</div>
</div>

</div> <!-- threadPage -->

<div id="qrModalOuter" class="hidden" onclick="hideQR()">
	<div id="qrModalInner" onclick="event.stopPropagation()">
		<div id="qrCode"></div>
	</div>
</div>

<!-- https://github.com/bitwiseshiftleft/sjcl/releases/tag/1.0.8 -->
<script src="static/sjcl/sjcl.js"></script>

<!-- https://github.com/englishextra/qrjs2/blob/e99eb11808ea83ab35ac2b9a291923c0b0084c18/js/qrjs2.min.js -->
<!-- The last line of the original (i.e. the source map reference) is removed. -->
<script src="static/qrjs2/qrjs2.min.js"></script>

<script>
const httpPost = function(url, data, cb) {
	var xhr = new XMLHttpRequest();
	xhr.open("POST", url);
	xhr.setRequestHeader("Accept", "application/json");
	xhr.setRequestHeader("Content-Type", "application/json");
	xhr.onreadystatechange = function () {
		if (xhr.readyState === 4) {
			if (xhr.status === 200) {
				cb({ok: true, responseText: xhr.responseText});
			} else {
				cb(xhr);
			}
		}
	};
	xhr.send(JSON.stringify(data));
}

const httpGet = function(url, cb) {
	var xhr = new XMLHttpRequest();
	xhr.onreadystatechange = function() { 
		if (xhr.readyState === 4) {
			if (xhr.status === 200) {
				cb({ok: true, responseText: xhr.responseText});
			} else {
				cb(xhr);
			}
		}
	}
	xhr.open("GET", url, true);
	xhr.send(null);
}


const stripCiphertext = function(fullCiphertext) {
	return {iv: fullCiphertext.iv, salt: fullCiphertext.salt, ct: fullCiphertext.ct};
};

const encryptionCache = {};

const encrypt = function(key, plaintext) {
	let ciphertext = JSON.stringify(stripCiphertext(JSON.parse(sjcl.encrypt(key, plaintext))));
	let cacheKey = key + ":" + ciphertext;
	if (!encryptionCache[cacheKey]) {
		encryptionCache[cacheKey] = plaintext;
	}
	return ciphertext;
};

const decrypt = function(key, ciphertext) {
	let cacheKey = key + ":" + ciphertext;
	if (encryptionCache[cacheKey]) {
		return encryptionCache[cacheKey];
	} else {
		let plaintext;
		try {
			plaintext = sjcl.decrypt(key, JSON.stringify(stripCiphertext(JSON.parse(ciphertext))));
			encryptionCache[cacheKey] = plaintext;
		} catch(e) {
			plaintext = "[[Decryption error]]";
			console.log("Decryption error:", e);
		}
		return plaintext;
	}
};

const ALPHABET = "abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789";
const BITS_PER_CHAR = Math.ceil(Math.log(ALPHABET.length)/Math.log(2));

const secureRandomString = function(length) {
	let string = "";
	for (let i=0; i<length; i++) {
		let index = Math.abs(sjcl.random.randomWords(1)[0]) % ALPHABET.length; 
		string += ALPHABET[index];
	}
	return string;
};

const remainder = function(byteArray, modulus) {
	let result = 0;
	for (let i=0; i<sjcl.bitArray.bitLength(byteArray); i++) {
		result = (result*2) % modulus;
		let bit = sjcl.bitArray.extract(byteArray,i,1);
		result = (result+bit) % modulus;
	}
	return result;
};

const hashToString = function(input, affix, outputLength) {
	let affixedInput = affix + ":" + input + ":" + affix;
	let hashBytes = sjcl.hash.sha256.hash(affixedInput);
	// This "encoding" is lossy, but we're throwing away ~half the bits anyway.
	let output = "";
	let end = sjcl.bitArray.bitLength(hashBytes)
	while (output.length < outputLength && end > 0) {
		let index = remainder(sjcl.bitArray.bitSlice(hashBytes, 0, end), ALPHABET.length);
		output += ALPHABET[index];
		end -= BITS_PER_CHAR;
	}
	return output;
};

const readingKeyFromRootKey = function(rootKey) {
	return hashToString(rootKey, READING_AFFIX, READING_KEY_LENGTH);
}
const writingKeyFromRootKey = function(rootKey) {
	return hashToString(rootKey, WRITING_AFFIX, WRITING_KEY_LENGTH);
}
const boardKeyFromReadingKey = function(readingKey) {
	return hashToString(readingKey, BOARD_AFFIX, BOARD_KEY_LENGTH);
}

const SECRET_KEY_LENGTH = 22; // Deprecated
const ROOT_KEY_LENGTH = SECRET_KEY_LENGTH;
const BOARD_CODE_LENGTH = 3; // Deprecated
const READING_AFFIX = "r";
const READING_KEY_LENGTH = SECRET_KEY_LENGTH+1;
const WRITING_AFFIX = "w";
const WRITING_KEY_LENGTH = SECRET_KEY_LENGTH+2;
const BOARD_AFFIX = "b";
const BOARD_KEY_LENGTH = 10;

const MY_BOARDS_LS_KEY = "myBoards";

const refreshMyBoards = function() {
	let myBoards = JSON.parse(window.localStorage.getItem(MY_BOARDS_LS_KEY) || "[]");
	let listElement = document.getElementById("myBoardsList");
	let divElement = document.getElementById("myBoardsDiv");
	if (myBoards.length) {
		let unexpiredCount = 0;
		let listHtml = "";
		let now = +new Date();
		for (let i=0; i<myBoards.length; i++) {
			let entry = myBoards[i];
			if (entry.expirationDateMs > now) {
				unexpiredCount++;
				let readOnly = entry.boardSlug.length === READING_KEY_LENGTH;
				listHtml += (
					'<a href="/#' + entry.boardSlug + '">' +
					entry.title +
					(readOnly ? '<sup>ro</sup>' : '') +
					'</a> '
				);
			}
		}
		if (unexpiredCount) {
			listElement.innerHTML = listHtml;
			divElement.classList.remove("hidden");
			return;
		}
	}
	listElement.innerText = "";
	divElement.classList.add("hidden");
};
refreshMyBoards(); // Show on initial homepage load

const clearMyBoards = function() {
	if (confirm("Are you sure? You will lose access to these boards if you have not saved their links elsewhere.")) {
		window.localStorage.clear();
		refreshMyBoards();
	}
};

const addMyBoard = function(boardSlug, title, expirationDateMs) {
	let myBoards = JSON.parse(window.localStorage.getItem(MY_BOARDS_LS_KEY) || "[]");
	let myBoardsNew = [];

	let rootKey;
	let readingKey;
	if (boardSlug.length === ROOT_KEY_LENGTH) {
		rootKey = boardSlug;
		readingKey = readingKeyFromRootKey(rootKey);
	} else if (boardSlug.length === READING_KEY_LENGTH) {
		rootKey = "";
		readingKey = boardSlug;
	}

	let shouldAdd = true;
	for (let i=0; i<myBoards.length; i++) {
		let entry = myBoards[i];
		// entry is superseded by boardSlug if entry is read-only,
		// boardSlug is not, and they both refer to the same board.
		let superseded = rootKey &&
			!entry.rootKey &&
			entry.readingKey && // TODO: remove old-style
			entry.readingKey === readingKey;
		if (!superseded) {
			if (entry.boardSlug === boardSlug || // entry is the same link as the new link
				entry.rootKey && readingKey && entry.readingKey === readingKey) { // entry itself supersedes the new link
				shouldAdd = false;
			}
			if (entry.expirationDateMs > +new Date()) {
				myBoardsNew.push(entry);
			}
		}
	}
	if (shouldAdd) {
		myBoardsNew.push({boardSlug, title, expirationDateMs, rootKey, readingKey});
	}
	
	window.localStorage.setItem(MY_BOARDS_LS_KEY, JSON.stringify(myBoardsNew));
};

const getWriteableLinkFromHistory = function(readingKey) {
	let myBoards = JSON.parse(window.localStorage.getItem(MY_BOARDS_LS_KEY) || "[]");
	for (let i=0; i<myBoards.length; i++) {
		let entry = myBoards[i];
		if (entry.readingKey === readingKey) {
			return entry.rootKey;
		}
	}
	return "";
};

const deriveKeys = function(boardSlug, wantWriteableLinkFromHistory) {
	let secretKey;
	let boardCode;
	let readOnly = false;
	let oldStyle = false; // TODO: remove

	let writingKey;
	let writeableLinkFromHistory;

	if (boardSlug.length === ROOT_KEY_LENGTH) {
		// new-style (writeable)
		secretKey = readingKeyFromRootKey(boardSlug);
		boardCode = boardKeyFromReadingKey(secretKey);
		writingKey = writingKeyFromRootKey(boardSlug);
	} else if (boardSlug.length === READING_KEY_LENGTH) {
		// new-style (read-only)
		secretKey = boardSlug;
		boardCode = boardKeyFromReadingKey(secretKey);
		readOnly = true;
		if (wantWriteableLinkFromHistory) {
			writeableLinkFromHistory = getWriteableLinkFromHistory(boardSlug);
		}
	} else if (boardSlug.length === SECRET_KEY_LENGTH + BOARD_CODE_LENGTH) {
		// old-style (TODO: remove)
		secretKey = boardSlug.substring(0, boardSlug.length-BOARD_CODE_LENGTH);
		boardCode = boardSlug.substring(boardSlug.length-BOARD_CODE_LENGTH);
		oldStyle = true;
	}

	return {secretKey, boardCode, readOnly, oldStyle, writingKey, writeableLinkFromHistory};
};


const createBoard = function() {
	let title = document.getElementById("newBoardTitle").value.trim() || "(Untitled)";
	let description = document.getElementById("newBoardDescription").value.trim() || "(No description)";
	let lifespanDays = parseInt(document.getElementById("newBoardLifespan").value.trim());

	clearErrors();
	let anyErrors = false;
	if (title.length > 100) {
		document.getElementById("titleError").innerText = "Too long (" + title.length + " characters)";
		anyErrors = true;
	}
	if (description.length > 1000) {
		document.getElementById("descriptionError").innerText = "Too long (" + description.length + " characters)";
		anyErrors = true;
	}
	if (isNaN(lifespanDays)) {
		document.getElementById("lifespanError").innerText = "Must be a number"
		anyErrors = true;
	} else if (lifespanDays > 35) {
		document.getElementById("lifespanError").innerText = "Too large"
		anyErrors = true;
	}
	if (anyErrors) {
		return;
	}

	let rootKey = secureRandomString(SECRET_KEY_LENGTH);
	let readingKey = readingKeyFromRootKey(rootKey);
	let boardKey = boardKeyFromReadingKey(readingKey);
	let writingKey = writingKeyFromRootKey(rootKey);

	let button = document.getElementById("createBoardButton");
	button.disabled = true;

	let titleCtString = encrypt(readingKey, title);
	let descriptionCtString = encrypt(readingKey, description);

	httpPost("/api/create_board", {
		lifespan_days: lifespanDays,
		title_ct: titleCtString,
		description_ct: descriptionCtString,
		board_key: boardKey,
		writing_key: writingKey
	}, function(response) {
		if (response.ok) {
			window.location.hash = rootKey;
		} else {
			alert("Error creating board! " + JSON.stringify(response));
		}
		button.disabled = null;
	});
};


const postReply = function() {
	let text = document.getElementById("replyText").value.trim();
	if (!text.length) {
		return;
	}
	if (text.length > 10000) {
		alert("Post is too long (>10000 characters)");
		return;
	}

	let splitHash = window.location.hash.slice(1).split("/");
	let boardSlug = splitHash[0];
	let lastPart = splitHash[1];
	let opId = lastPart.split("#")[0];

	let {secretKey, boardCode, readOnly, writingKey} = deriveKeys(boardSlug);
	if (readOnly) {
		alert("Cannot post from a read-only link");
		return;
	}

	let button = document.getElementById("postReplyButton");
	button.disabled = true;
	let writersOnly = document.getElementById("postReplyWo").checked;
	let textCt = encrypt(writersOnly ? secretKey + ":" + writingKey : secretKey, text);

	httpPost("/api/create_post", {
		text_ct: textCt,
		board_code: boardCode,
		parent_post_id: opId,
		writing_key: writingKey,
		writers_only: writersOnly
	}, function(response) {
		if (response.ok) {
			let currentHash = window.location.hash.slice(1);
			if (currentHash.indexOf("#") !== -1) {
				currentHash = currentHash.split("#")[0];
			}
			let newHash = currentHash + "#" + response.responseText;
			window.location.hash = newHash;
		} else {
			alert("Error creating post! " + JSON.stringify(response));
		}
		button.disabled = null;
	});
}


const renderText = function(original, postIdsOnPage, threadHash, mentionedPostsOutput) {
	let paragraphs = original.trim().split(/\n\n+/);
	let result = "";
	for (let i=0; i<paragraphs.length; i++) {
		let paragraph = paragraphs[i];
		let lines = paragraph.split("\n");
		result += "<p>";
		for (let j=0; j<lines.length; j++) {
			let line = lines[j].trim();
			let green = line.startsWith(">") && !line.startsWith(">>");
			let escapedLine = line
				.replace(/&/g, "&amp;")
				.replace(/</g, "&lt;")
				.replace(/>/g, "&gt;");

			let words = escapedLine.split(" ");
			let linkifiedLine = "";
			for (let k=0; k<words.length; k++) {
				let word = words[k];
				let wordSubstring = word.substring(8);
				let mentionedPost = parseInt(wordSubstring);
				if (postIdsOnPage &&
					word.startsWith("&gt;&gt;") &&
					!isNaN(mentionedPost) &&
					wordSubstring === ""+mentionedPost &&
					postIdsOnPage.indexOf(mentionedPost) !== -1) {
					linkifiedLine += (
						'<a href="/#' +
						threadHash + "#" + mentionedPost +
						'">' + word + '</a>'
					);
					if (mentionedPostsOutput.indexOf(mentionedPost) === -1) {
						mentionedPostsOutput.push(mentionedPost);
					}
				} else {
					linkifiedLine += word;
				}
				linkifiedLine += " ";
			}
			linkifiedLine = linkifiedLine.trim();

			if (green) {
				result += '<span class="greentext">';
			}
			result += linkifiedLine;
			if (green) {
				result += "</span>";
			}
			if (j<lines.length-1) {
				result += "<br/>";
			}
		}
		result += "</p>";
	}
	return result;
};


const clearForms = function() {
	document.getElementById("newThreadText").value = "";
	document.getElementById("newBoardTitle").value = "";
	document.getElementById("newBoardDescription").value = "";
	document.getElementById("newBoardLifespan").value = "";
	document.getElementById("replyText").value = "";
	document.getElementById("newThreadWo").checked = null;
	document.getElementById("postReplyWo").checked = null;
	clearErrors();
}

const clearErrors = function() {
	document.getElementById("titleError").innerText = "";
	document.getElementById("descriptionError").innerText = "";
	document.getElementById("lifespanError").innerText = "";
}

const PAGES = [
	"loadingPage",
	"badLinkPage",
	"incompleteLinkPage",
	"homePage",
	"boardPage",
	"threadPage"
];

const hideAllBut = function(pageToShow) {
	hideQR();
	stopCountdown();
	for (let i=0; i<PAGES.length; i++) {
		let page = PAGES[i];
		let element = document.getElementById(page);
		if (page === pageToShow) {
			element.classList.remove("hidden");
		} else {
			element.classList.add("hidden");
		}
	}
}


const formatTimestamp = function(timestampMs) {
	return new Date(timestampMs)
		.toISOString()
		.replace("T", " ").replace(/\.\d\d\dZ/, "");
}

const THREAD_ON_BOARD_TEMPLATE = 
`<div class="thread">
<div class="post">
<b>Anonymous</b> <a href="/#{{boardSlug}}/{{opId}}#{{opId}}">#{{opId}}</a> {{timestamp}} {{woMarker}}
{{renderedText}}
</div>
{{lastRepliesHtml}}
<a href="/#{{boardSlug}}/{{opId}}">{{replyLinkText}}</a>
</div>`;

const POST_PREVIEW_TEMPLATE =
`<div class="post">
<b>Anonymous</b> <a href="/#{{boardSlug}}/{{opId}}#{{postId}}">#{{postId}}</a> {{timestamp}} {{woMarker}}
{{renderedText}}
</div>`;

const HIDDEN_REPLIES_TEMPLATE = `
<p>{{hiddenCount}} repl{{pluralEnding}} hidden; <a href="/#{{boardSlug}}/{{opId}}">view all</a></p>`;

const WO_REDACTED = "<p class='woRedacted'>[Visible to writers only]</p>";

const MS_PER_DAY = 1000*60*60*24;
const MS_PER_HOUR = 1000*60*60;
const MS_PER_MINUTE = 1000*60;
const MS_PER_SECOND = 1000;
const formatDuration = function(durationMs) {
	durationMs = Math.max(durationMs, 0);
	let days = Math.floor(durationMs / MS_PER_DAY);
	durationMs -= days*MS_PER_DAY;
	let hours = Math.floor(durationMs / MS_PER_HOUR);
	durationMs -= hours*MS_PER_HOUR;
	let minutes = Math.floor(durationMs / MS_PER_MINUTE);
	durationMs -= minutes*MS_PER_MINUTE;
	let seconds = Math.floor(durationMs / MS_PER_SECOND);
	if (days === 0 && hours === 0 && minutes < 10) {
		// When <10min, pad it out so it doesn't change size during the countdown
		return minutes + " minutes " + (seconds>=10 ? seconds : "0"+seconds) + " seconds" 
	} else {
		return ""
			+ (days ? days + " day" + (days === 1 ? "" : "s") + " " : "")
			+ (hours ? hours + " hour" + (hours === 1 ? "" : "s") + " " : "")
			+ (minutes ? minutes + " minute" + (minutes === 1 ? "" : "s") : "");
	}
};

let countdownInterval = void(0);

const startCountdown = function(element, countdownToMs) {
	if ("undefined" !== typeof(countdownInterval)) {
		clearInterval(countdownInterval);
	}
	countdownInterval = setInterval(function(){
		let duration = countdownToMs - new Date();
		element.innerText = formatDuration(duration);
		if (duration <= 0) {
			document.body.classList.add("fadeout");
			stopCountdown();
		}
	}, 100);
}

const stopCountdown = function() {
	if ("undefined" !== typeof(countdownInterval)) {
		countdownInterval = clearInterval(countdownInterval);
	}
}

const showBoard = function(boardSlug, pageNum) {
	let {secretKey, boardCode, writingKey, readOnly, oldStyle, writeableLinkFromHistory} =
		deriveKeys(boardSlug, true/*wantWriteableLinkFromHistory*/);
				
	httpGet("/api/get_board?board_code=" +
			encodeURIComponent(boardCode) +
			(pageNum>1 ? "&page=" + pageNum : ""), function(response) {
		if (!response.ok) {
			if (response.status === 404) {
				showBadLink();
			} else {
				alert("Error getting board! " + JSON.stringify(response));
			}
			return;
		}
		let resObj = JSON.parse(response.responseText);
		let boardObj = resObj.board;
		let threads = resObj.threads;
		let pageCount = resObj.page_count;

		// Board info:
		let titleCt = boardObj.title_ct;
		let descriptionCt = boardObj.description_ct;
		let expirationDateMs = boardObj.expiration_date_ms;
		let title = decrypt(secretKey, titleCt);
		let description = decrypt(secretKey, descriptionCt);

		addMyBoard(boardSlug, title, expirationDateMs);

		document.getElementById("htmlTitle").innerText = title + " : Tempchan" + (readOnly ? " [read-only]" : "");
		document.getElementById("boardTitle").innerText = title;
		document.getElementById("boardDescription").innerHTML = renderText(description);
		document.getElementById("rssLink").href = "/api/rss?board=" + boardCode;
		document.getElementById("boardPage").classList[readOnly ? "add" : "remove"]("readOnly");

		let otherAccessLinkText = "";
		if (!oldStyle) {
			if (!readOnly) {
				otherAccessLinkText = "Read-only link";
				document.getElementById("otherAccessLink").href = "#" + secretKey;
			} else if (writeableLinkFromHistory) {
				otherAccessLinkText = "Writeable link";
				document.getElementById("otherAccessLink").href = "#" + writeableLinkFromHistory;
			}
		}
		document.getElementById("otherAccessLink").innerText = otherAccessLinkText;
		document.getElementById("otherAccessLinkSpan").classList[otherAccessLinkText ? "remove" : "add"]("hidden");

		let pagination = "";
		if (pageCount > 1) {
			pagination += "Page:";
			for (let i=1; i<=pageCount; i++) {
				if (i === pageNum) {
					pagination += ' <b>' + i + '</b>';
				} else {
					let pageLink = "/#" + boardSlug;
					if (i > 1) {
						pageLink += "/p/" + i;
					}
					pagination += ' <a href="' + pageLink + '">' + i + '</a>';
				}
			}
		}
		document.getElementById("paginationTop").innerHTML = pagination;
		document.getElementById("paginationBottom").innerHTML = pagination;

		// Thread listing:
		let threadsHtml = "";
		for (let i=0; i<threads.length; i++) {
			let thread = threads[i];
			let redact = thread.op.writers_only && readOnly;
			let decryptionKey = thread.op.writers_only ? secretKey + ":" + writingKey : secretKey;
			let opText = redact ? WO_REDACTED : renderText(decrypt(decryptionKey, thread.op.text_ct));
			let lastRepliesHtml = "";
			if (thread.op.replies_count) {
				let hiddenCount = thread.op.replies_count - thread.last_replies.length;
				if (hiddenCount) {
					lastRepliesHtml += HIDDEN_REPLIES_TEMPLATE
						.replaceAll("{{hiddenCount}}", hiddenCount)
						.replaceAll("{{pluralEnding}}", hiddenCount>1 ? "ies" : "y")
						.replaceAll("{{boardSlug}}", boardSlug)
						.replaceAll("{{opId}}", thread.op.post_id);
				}
				
				// Iterate backwards since the API returns them in reverse order
				for (let j=thread.last_replies.length-1; j>=0; j--) {
					let reply = thread.last_replies[j];
					let redact = reply.writers_only && readOnly;
					let decryptionKey = reply.writers_only ? secretKey + ":" + writingKey : secretKey;
					let replyText = redact ? WO_REDACTED : renderText(decrypt(decryptionKey, reply.text_ct));
					lastRepliesHtml += POST_PREVIEW_TEMPLATE
						.replaceAll("{{boardSlug}}", boardSlug)
						.replaceAll("{{opId}}", thread.op.post_id)
						.replaceAll("{{postId}}", reply.post_id)
						.replaceAll("{{timestamp}}", formatTimestamp(reply.timestamp_ms))
						.replaceAll("{{woMarker}}", reply.writers_only ? WO_MARKER : "")
						.replaceAll("{{renderedText}}", replyText);
				}
			}
			let threadHtml = THREAD_ON_BOARD_TEMPLATE
				.replaceAll("{{boardSlug}}", boardSlug)
				.replaceAll("{{opId}}", thread.op.post_id)
				.replaceAll("{{timestamp}}", formatTimestamp(thread.op.timestamp_ms))
				.replaceAll("{{woMarker}}", thread.op.writers_only ? WO_MARKER : "")
				.replaceAll("{{renderedText}}", opText)
				.replaceAll("{{lastRepliesHtml}}", lastRepliesHtml)
				.replaceAll("{{replyLinkText}}", readOnly ? "View thread" : "Reply");
			threadsHtml += threadHtml;
		}
		document.getElementById("threadsView").innerHTML = threadsHtml;

		let timeTillDeletionMs = expirationDateMs - new Date();
		document.getElementById("boardDeletionCountdown").innerText = formatDuration(timeTillDeletionMs);
		document.getElementById("boardDeletionCountdown").title = formatTimestamp(expirationDateMs);
		clearForms();
		hideAllBut("boardPage");
		if (timeTillDeletionMs < 10*MS_PER_MINUTE) {
			startCountdown(document.getElementById("boardDeletionCountdown"), expirationDateMs);
		}
	});
};

const QR_DESIRED_SIZE = 145;
const QR_CELL_SIZE = 5;
const showQR = function() {
	let qrTable = QRCode.generateHTML(window.location.href);
	let actualSize = qrTable.getElementsByTagName("tr").length * QR_CELL_SIZE;
	let qrDiv = document.getElementById("qrCode");
	qrDiv.appendChild(qrTable);
	if (actualSize !== QR_DESIRED_SIZE) {
		let scale = QR_DESIRED_SIZE/actualSize;
		qrDiv.style.setProperty("transform", "scale(" + scale + ")");
	}
	document.getElementById("qrModalOuter").classList.remove("hidden");
};

const hideQR = function() {
	document.getElementById("qrCode").innerHTML = "";
	document.getElementById("qrModalOuter").classList.add("hidden");
};

const POST_ON_THREAD_TEMPLATE = `
<div class="post{{highlightStyle}}" id="post{{postId}}">
<b>Anonymous</b> <a href="/#{{boardSlug}}/{{opId}}#{{postId}}">#{{postId}}</a> 
<a class="mentioner" href="" onclick="mention({{postId}}); return false" title="Mention this post">&lt;&lt;</a> 
{{timestamp}} {{woMarker}} {{backmentions}}
{{renderedText}}
</div>`;

const WO_MARKER = "<sup class='writersOnlyMarker' title='Visible to writers only'>[wo]</sup>";

const showThread = function(boardSlug, opId, highlitPost) {
	let {secretKey, boardCode, readOnly, writingKey} = deriveKeys(boardSlug);

	httpGet("/api/get_thread?board_code=" + encodeURIComponent(boardCode) + "&op_id=" + opId, function(response) {
		if (!response.ok) {
			if (response.status === 404) {
				showBadLink();
			} else {
				alert("Error getting thread! " + JSON.stringify(response));
			}
			return;
		}
		let res = JSON.parse(response.responseText);
		let posts = res.posts;
		if (!posts || posts[0].parent_post_id) {
			// Don't allow linking directly to a single reply
			showBadLink();
			return;
		}
		let board = res.board;
		let boardTitle = decrypt(secretKey, board.title_ct);
		let expirationDateMs = board.expiration_date_ms;
		addMyBoard(boardSlug, boardTitle, expirationDateMs);

		document.getElementById("htmlTitle").innerText =
			boardTitle + " | #" + opId + " : Tempchan" + (readOnly ? " [read-only]" : "");
		
		// First pass: Assemble the list of postIds
		let postIdsOnPage = [];
		let postIdToIndex = {};
		for (let i=0; i<posts.length; i++) {
			let post = posts[i];
			postIdsOnPage.push(post.post_id);
			postIdToIndex[post.post_id] = i;
		}

		// Second pass: Render the text, and get list of mentions in each post
		let renderedTexts = [];
		let mentionsInEachPost = [];
		let threadHash = boardSlug + "/" + opId;
		for (let i=0; i<posts.length; i++) {
			let post = posts[i];
			let mentionsInPost = [];
			let redact = post.writers_only && readOnly;
			let decryptionKey = post.writers_only ? secretKey + ":" + writingKey : secretKey;
			let renderedText = redact ? WO_REDACTED : renderText(
				decrypt(decryptionKey, post.text_ct),
				postIdsOnPage,
				threadHash,
				mentionsInPost
			);
			renderedTexts.push(renderedText);
			mentionsInEachPost.push(mentionsInPost);
		}

		// Third pass: Invert the post -> mentions mapping
		let mentionsOfEachPost = [];
		for (let i=0; i<posts.length; i++) {
			let mentions = mentionsInEachPost[i];
			for (let j=0; j<mentions.length; j++) {
				let mention = mentions[j];
				let index = postIdToIndex[mention];
				if (!mentionsOfEachPost[index]) {
					mentionsOfEachPost[index] = [];
				}
				mentionsOfEachPost[index].push(postIdsOnPage[i]);
			}
		}

		// Fourth and final pass: Assemble the HTML for the page
		let threadHtml = "";
		for (let i=0; i<posts.length; i++) {
			let post = posts[i];
			let mentionsOfThisPost = mentionsOfEachPost[i] || [];
			let backmentionsHtml = "";
			for (let j=0; j<mentionsOfThisPost.length; j++) {
				let mention = mentionsOfThisPost[j];
				backmentionsHtml += (
					'<a href="/#' +
					threadHash + 
					"#" +
					mention +
					'">&gt;&gt;' +
					mention +
					'</a> '
				);
			}
			
			let postHtml = POST_ON_THREAD_TEMPLATE
				.replaceAll("{{boardSlug}}", boardSlug)
				.replaceAll("{{opId}}", opId)
				.replaceAll("{{postId}}", post.post_id)
				.replaceAll("{{timestamp}}", formatTimestamp(post.timestamp_ms))
				.replaceAll("{{woMarker}}", post.writers_only ? WO_MARKER : "")
				.replaceAll("{{backmentions}}", backmentionsHtml)
				.replaceAll("{{renderedText}}", renderedTexts[i])
				.replaceAll("{{highlightStyle}}", highlitPost === post.post_id ? " highlit" : "");
			threadHtml += postHtml;
		}

		document.getElementById("fullThread").innerHTML = threadHtml;
		document.getElementById("threadBoardTitle").innerText = boardTitle;
		document.getElementById("threadBoardTitle").href = "/#" + boardSlug;
		fillThreadHeader(boardSlug, opId, highlitPost);

		let timeTillDeletionMs = expirationDateMs - new Date();
		document.getElementById("threadDeletionCountdown").innerText = formatDuration(timeTillDeletionMs);
		document.getElementById("threadDeletionCountdown").title = formatTimestamp(expirationDateMs);
		clearForms();
		document.getElementById("threadPage").classList[readOnly ? "add" : "remove"]("readOnly");
		hideAllBut("threadPage");

		if (timeTillDeletionMs < 10*MS_PER_MINUTE) {
			startCountdown(document.getElementById("threadDeletionCountdown"), expirationDateMs);
		}

		if (highlitPost) {
			let highlitPostElement = document.getElementById("post" + highlitPost);
			if (highlitPostElement) {
				highlitPostElement.scrollIntoView();
			}
		}
	});
};

const fillThreadHeader = function(boardSlug, opId, highlitPost) {
	let highlitPostElement = highlitPost && document.getElementById("post" + highlitPost);
	if (highlitPostElement) {
		document.getElementById("threadHeader").innerHTML =
			"<a href='/#" + boardSlug + "/" + opId + "'>#" + opId + "</a>";
	} else {
		document.getElementById("threadHeader").innerText = "#" + opId;
	}
}

const mention = function(postId) {
	let replyTextField = document.getElementById("replyText");
	let replyTextValue = replyTextField.value;
	let spacer = "";
	if (replyTextValue && replyTextValue[replyTextValue.length-1].trim()) {
		// If it ends with non-whitespace, insert whitespace
		spacer = " ";
	}
	replyTextField.value = replyTextValue + spacer + ">>" + postId + " ";
	replyTextField.scrollIntoView();
}

const rescrollThread = function(boardSlug, opId, highlitPost) {
	let oldHighlitElement = document.getElementsByClassName("highlit")[0];
	if (oldHighlitElement) {
		oldHighlitElement.classList.remove("highlit");
	}
	if (!oldHighlitElement !== !highlitPost) {
		fillThreadHeader(boardSlug, opId, highlitPost);
	}
	if (highlitPost) {
		let element = document.getElementById("post" + highlitPost);
		if (element) {
			element.classList.add("highlit");
			element.scrollIntoView();
		} else {
			showLoading();
			showThread(boardSlug, opId, highlitPost);
		}
	} else {
		window.scrollTo(0,0);
	}
}

const showBadLink = function() {
	document.getElementById("htmlTitle").innerText = "Tempchan : not found";
	hideAllBut("badLinkPage");
}

const showIncompleteLink = function() {
	document.getElementById("htmlTitle").innerText = "Tempchan : incomplete link";
	hideAllBut("incompleteLinkPage");
}

const showLoading = function() {
	hideAllBut("loadingPage");
}

const showHome = function() {
	clearForms();
	document.getElementById("htmlTitle").innerText = "Tempchan : throwaway discussion boards";
	refreshMyBoards();
	hideAllBut("homePage");
}


const newThread = function() {
	let text = document.getElementById("newThreadText").value.trim();
	if (!text.length) {
		return;
	}
	if (text.length > 10000) {
		alert("Post is too long (>10000 characters)");
		return;
	}

	let boardSlug = window.location.hash.slice(1);
	let {secretKey, boardCode, readOnly, writingKey} = deriveKeys(boardSlug);
	if (readOnly) {
		alert("Cannot post from a read-only link");
		return;
	}

	let button = document.getElementById("newThreadButton");
	button.disabled = true;
	let writersOnly = document.getElementById("newThreadWo").checked;
	let textCtString = encrypt(writersOnly ? secretKey + ":" + writingKey : secretKey, text);

	httpPost("/api/create_post", {
		text_ct: textCtString,
		board_code: boardCode,
		writing_key: writingKey,
		writers_only: writersOnly
	}, function(response) {
		if (response.ok) {
			let newHash = boardSlug + "/" + response.responseText;
			window.location.hash = newHash;
		} else {
			alert("Error creating post! " + JSON.stringify(response));
		}
		button.disabled = null;
	});
}

// TODO: make this more efficient
const findBoardSlug = function(boardCode) {
	let myBoards = JSON.parse(window.localStorage.getItem(MY_BOARDS_LS_KEY) || "[]");
	for (let i=0; i<myBoards.length; i++) {
		let entry = myBoards[i];
		if (boardCode.length === BOARD_CODE_LENGTH && // old-style (TODO: remove)
				entry.boardSlug.endsWith(boardCode) ||
			boardCode.length === BOARD_KEY_LENGTH && ( // new-style
					entry.boardSlug.length === ROOT_KEY_LENGTH && // (writeable)
						boardKeyFromReadingKey(readingKeyFromRootKey(entry.boardSlug)) === boardCode ||
					entry.boardSlug.length === READING_KEY_LENGTH && // (read-only)
						boardKeyFromReadingKey(entry.boardSlug) === boardCode
				)
			) {
			return entry.boardSlug;
		}
	}
	return false;
};


const handleHash = function(oldHash) {
	if (window.location.hash) {
		let newHash = window.location.hash.slice(1);
		let splitHash = newHash.split("/");
		if (newHash.endsWith("/")) {
			// Strip trailing slashes
			let stripped = newHash;
			while (stripped && stripped.endsWith("/")) {
				stripped = stripped.substring(0, stripped.length-1);
			}
			// Redirect:
			if (stripped) {
				window.location.replace("#"+stripped);
			} else {
				window.location.replace("");
			}
		} else if (splitHash[0].length === BOARD_KEY_LENGTH || // new-style
			splitHash[0].length === BOARD_CODE_LENGTH // old-style (TODO: remove)
			) {
			// Redirect from RSS link
			let boardSlugFromHistory = findBoardSlug(splitHash[0]);
			if (boardSlugFromHistory) {
				// Redirect:
				splitHash[0] = boardSlugFromHistory;
				let redirectToHash = splitHash.join("/");
				window.location.replace("#"+redirectToHash);
			} else {
				showIncompleteLink();
			}
		} else if (splitHash[0].length === ROOT_KEY_LENGTH || // new-style (writeable)
				splitHash[0].length === READING_KEY_LENGTH || // new-style (read-only)
				splitHash[0].length === SECRET_KEY_LENGTH + BOARD_CODE_LENGTH // old-style (TODO: remove)
				) {
			// Board or thread view
			let boardSlug = splitHash[0];
			if (splitHash.length === 1) {
				showLoading();
				showBoard(boardSlug, 1);
			} else if (splitHash.length === 2) {
				let lastPart = splitHash[1];
				let opIdString;
				let highlitPost;
				if (lastPart.indexOf("#") !== -1) {
					let lastPartSplit = lastPart.split("#");
					opIdString = lastPartSplit[0];
					highlitPost = parseInt(lastPartSplit[1]);
				} else {
					opIdString = lastPart;
					highlitPost = 0;
				}
				let opId = parseInt(opIdString);

				if (isNaN(opId) || opId <= 0 || ""+opId !== opIdString ||
						isNaN(highlitPost) || highlitPost < 0
						) {
					showBadLink();
				} else {
					let oldHashPrefix = oldHash && oldHash.split("#")[0];
					if (document.getElementById("badLinkPage").classList.contains("hidden") &&
						oldHashPrefix && (
						newHash === oldHashPrefix ||
						newHash.startsWith(oldHashPrefix+"#"))
					) {
						rescrollThread(boardSlug, opId, highlitPost);
					} else {
						showLoading();
						showThread(boardSlug, opId, highlitPost);
					}
				}
			} else if (splitHash.length === 3 && splitHash[1] === "p") {
				let pageNum = parseInt(splitHash[2]);
				if (pageNum) {
					if (pageNum === 1) {
						// Redirect:
						window.location.replace("#"+boardSlug);
					} else {
						showLoading();
						showBoard(boardSlug, pageNum);
					}
				} else {
					showBadLink();
				}
			} else {
				showBadLink();
			}
		} else {
			showBadLink();
		}
	} else {
		showHome();
	}
};

window.onload = function() {
	handleHash();
};

window.onhashchange = function(event) {
	let oldURL = event.oldURL;
	let index = oldURL.indexOf("#");
	let oldHash = "";
	if (index !== -1) {
		oldHash = oldURL.slice(1+index);
	}
	handleHash(oldHash);
};

</script>
</body>
</html>
