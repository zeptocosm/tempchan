<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title id="htmlTitle">Tempchan : throwaway discussion boards</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŒ¸</text></svg>"/>
<style>
body {
	background-color: #eee;
	font-family: Tahoma, Helvetica, sans-serif;
}	
@keyframes fadeout {
	from {opacity: 1}
	to {opacity: 0}
}
body.fadeout {
	animation-name: fadeout;
	animation-duration: 20s;
	opacity: 0;
}

h1, #homePage>p, #myBoardsDiv, #myBoardsDiv *, #loadingPage *, #badLinkPage *, #incompleteLinkPage * {
	text-align: center;
}

#creationForm {
	max-width: min(100%, 720px);
	padding: 10px;
	padding-top: 0;
	border: 5px solid black;
	background-color: white;
	margin-left: auto;
	margin-right: auto;
}
div.formValue {
	margin-bottom: 10px;
}
div.formValue:last-child {
	margin-bottom: 0;
}

.formValue div {
	display: inline-block;
}

.error {
	color: red;
}

#boardPage, #threadPage, #badLinkPage, #incompleteLinkPage {
	margin-left: 2%;
	margin-right: 2%;
	max-width: 960px;
}

.thread {
	border: 1px solid black;
	padding: 5px;
	margin-top: 20px;
}
.thread.top {
	margin-top: 0;
}

#creationForm ul, #boardDescription {
	text-align: justify;
}

.post p {
	margin-left: 10px;
	margin-right: 10px;
	text-align: justify;
}

.highlit {
	background-color: white;
}

.greentext {
	color: #090;
}

.pagination {
	margin-top: 15px;
	margin-bottom: 15px;
}

#newBoardDescription {
	max-width: 100%;
}

.hidden {
	display: none;
}

#myBoardsDiv h3 {
	display: inline;
}
#myBoardsDiv h3, #myBoardsList a {
	margin-right: 10px;
}

.textareaContainer {
	display: inline-block;
	max-width: 100%;
}
.textareaContainer textarea {
	max-width: 98%;
}
.textareaContainer > div > div:nth-child(1) {
	float: left;
}
.textareaContainer > div > div:nth-child(2) {
	float: right;
}
.textareaContainer > div > div:nth-child(3) {
	clear: both;
}

#qrModalOuter {
	background-color: rgb(0,0,0);
	background-color: rgba(0,0,0,0.5);
	width: 100%;
	height: 100%;
	position: fixed;
	z-index: 1;
	left: 0;
	top: 0;
}
#qrModalInner {
	background-color: white;
	width: 200px;
	height: 200px;
	border: 5px solid black;
	margin-left: auto;
	margin-right: auto;
	position: relative;
	top: 150px;
}
#qrCode {
	position: relative;
	top: 26px;
	transform-origin: top center;
}
#qrCode table {
	margin-left: auto;
	margin-right: auto;
}


</style>
</head>
<body>

<div id="loadingPage" class="hidden"><h2>Loading...</h2></div>

<div id="badLinkPage" class="hidden">
	<h2>Bad link!</h2>
	<p>The thing you're looking for doesn't exist, or has expired.</p>
	<p><a href="/">Back to home</a></p>
</div>

<div id="incompleteLinkPage" class="hidden">
	<h2>Incomplete link!</h2>
	<p>You've come here from an RSS feed for a board whose secret link is not in your history; therefore the board cannot be decrypted. Visit the board at its complete link (with <code>#</code> followed by 25 characters), and then reload this page.
	<p><a href="/">Back to home</a></p>
</div>

<div id="homePage">

<h1>ðŸŒ¸ Tempchan</h1>

<p><b>Tempchan</b> is a way of making anonymous, private, temporary discussion boards. <a href="/about.html">Learn more</a></p>

<p class="error" id="noscriptWarning">Tempchan requires JavaScript to run, in order to encrypt and decrypt messages in your web browser.</p>
<script>document.getElementById("noscriptWarning").style = "display:none";</script>

<div id="myBoardsDiv" class="hidden"><p>
<h3>My boards:</h3>
<span id="myBoardsList"></span>
<button onclick="clearMyBoards()">Clear</button>
</p></div>

<div id="creationForm">

<h2>Create a new board</h2>

<div>
<div class="formValue">
	<div><b>Title</b></div>
	<div>(max 100 characters)</div>
	<div><input type="text" placeholder="(Untitled)" id="newBoardTitle"/></div>
	<div class="error" id="titleError"></div>
</div>
<div class="formValue">
	<div><b>Description</b></div>
	<div>(max 1000 characters)</div>
	<div class="error" id="descriptionError"></div>
	<div style="display:block"><textarea cols="60" rows="3" placeholder="(optional)" id="newBoardDescription"></textarea></div>
</div>
<div class="formValue">
	<div><b>Lifespan (days)</b></div>
	<div>(max 35)</div>
	<div><input type="text" style="max-width:30px" id="newBoardLifespan"/></div>
	<div class="error" id="lifespanError"></div>
</div>
</div>

<ul>
	<li>Once the board is created, these settings cannot be changed. Copy its link and share it with others to invite them.</li>
	<li>Anyone with the link can read and write posts on the board, but nobody else can. Posts cannot be deleted once submitted.</li>
	<li>The board (and all of its posts) will be deleted at midnight (GMT) after the given lifespan has elapsed.</li>
</ul>

<button id="createBoardButton" onclick="createBoard()">Create board and take me there</button>

</div>

<hr/>
<p><a href="https://github.com/zeptocosm/tempchan" rel="noopener noreferrer" target="_blank">Source code</a> | Released under <a href="https://github.com/zeptocosm/tempchan/blob/main/LICENSE.txt" rel="noopener noreferrer" target="_blank">AGPLv3</a></p>

</div><!-- homePage -->


<div id="boardPage" class="hidden">

<h1><a href="#">Tempchan</a> | <span id="boardTitle"></span></h1>

<h3 style="text-align: center">Time till deletion: <span id="boardDeletionCountdown"></span><br/><a href="" onclick="showQR(); return false">QR</a> &middot; <a id="rssLink" href="" target="_blank" rel="noopener noreferrer">RSS</a></h3>

<div id="boardDescription"></div>

<div class="textareaContainer">
<textarea id="newThreadText" cols="60" rows="5"></textarea>
<div>
<div><button id="newThreadButton" onclick="newThread()">Post new thread</button></div>
<div><a href="/about.html#how-can-i-use-text-formatting-in-my-posts" target="_blank">Help</a></div>
<div></div>
</div>
</div>

<hr/>

<div id="paginationTop" class="pagination"></div>

<div id="threadsView"></div>

<div id="paginationBottom" class="pagination"></div>

</div> <!-- boardPage -->


<div id="threadPage" class="hidden">

<h1><a href="#">Tempchan</a> | <a href="" id="threadBoardTitle">(board title)</a> | #<span id="threadHeader"></span></h1>

<h3 style="text-align: center">Time till deletion: <span id="threadDeletionCountdown"></span></h3>

<div id="fullThread"></div>

<div class="textareaContainer">
<textarea id="replyText" cols="60" rows="5"></textarea>
<div>
<div><button id="postReplyButton" onclick="postReply()">Reply</button></div>
<div><a href="/about.html#how-can-i-use-text-formatting-in-my-posts" target="_blank">Help</a></div>
<div></div>
</div>
</div>

</div> <!-- threadPage -->

<div id="qrModalOuter" class="hidden" onclick="hideQR()">
	<div id="qrModalInner" onclick="event.stopPropagation()">
		<div id="qrCode"></div>
	</div>
</div>

<!-- https://github.com/bitwiseshiftleft/sjcl/releases/tag/1.0.8 -->
<script src="static/sjcl/sjcl.js"></script>

<!-- https://github.com/englishextra/qrjs2/blob/e99eb11808ea83ab35ac2b9a291923c0b0084c18/js/qrjs2.min.js -->
<!-- The last line of the original (i.e. the source map reference) is removed. -->
<script src="static/qrjs2/qrjs2.min.js"></script>

<script>
const httpPost = function(url, data, cb) {
	var xhr = new XMLHttpRequest();
	xhr.open("POST", url);
	xhr.setRequestHeader("Accept", "application/json");
	xhr.setRequestHeader("Content-Type", "application/json");
	xhr.onreadystatechange = function () {
		if (xhr.readyState === 4) {
			if (xhr.status === 200) {
				cb({ok: true, responseText: xhr.responseText});
			} else {
				cb(xhr);
			}
		}
	};
	xhr.send(JSON.stringify(data));
}

const httpGet = function(url, cb) {
	var xhr = new XMLHttpRequest();
	xhr.onreadystatechange = function() { 
		if (xhr.readyState === 4) {
			if (xhr.status === 200) {
				cb({ok: true, responseText: xhr.responseText});
			} else {
				cb(xhr);
			}
		}
	}
	xhr.open("GET", url, true);
	xhr.send(null);
}


const stripCiphertext = function(fullCiphertext) {
	return {iv: fullCiphertext.iv, salt: fullCiphertext.salt, ct: fullCiphertext.ct};
};

const expandCiphertext = function(strippedCiphertext) {
	let expanded = {"v":1,"iter":10000,"ks":128,"ts":64,"mode":"ccm","adata":"","cipher":"aes", ...strippedCiphertext};
	if (expanded.iter) {
		delete expanded["iter"];
	}
	return expanded;
};

const encryptionCache = {};

const encrypt = function(key, plaintext) {
	let ciphertext = JSON.stringify(stripCiphertext(JSON.parse(sjcl.encrypt(key, plaintext))));
	let cacheKey = key + ":" + ciphertext;
	if (!encryptionCache[cacheKey]) {
		encryptionCache[cacheKey] = plaintext;
	}
	return ciphertext;
};

const decrypt = function(key, ciphertext) {
	let cacheKey = key + ":" + ciphertext;
	if (encryptionCache[cacheKey]) {
		return encryptionCache[cacheKey];
	} else {
		let plaintext;
		try {
			plaintext = sjcl.decrypt(key, JSON.stringify(expandCiphertext(JSON.parse(ciphertext))));
			encryptionCache[cacheKey] = plaintext;
		} catch(e) {
			plaintext = "[[Decryption error]]";
			console.log("Decryption error:", e);
		}
		return plaintext;
	}
};

const ALPHABET = "abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789";
const secureRandomString = function(length) {
	let string = "";
	for (let i=0; i<length; i++) {
		let index = Math.abs(sjcl.random.randomWords(1)[0]) % ALPHABET.length; 
		string += ALPHABET[index];
	}
	return string;
};

const SECRET_KEY_LENGTH = 22;
const BOARD_CODE_LENGTH = 3;

const MY_BOARDS_LS_KEY = "myBoards";

const refreshMyBoards = function() {
	let myBoards = JSON.parse(window.localStorage.getItem(MY_BOARDS_LS_KEY) || "[]");
	let listElement = document.getElementById("myBoardsList");
	let divElement = document.getElementById("myBoardsDiv");
	if (myBoards.length) {
		let listHtml = "";
		let now = +new Date();
		for (let i=0; i<myBoards.length; i++) {
			let entry = myBoards[i];
			if (entry.expirationDateMs > now) {
				listHtml += ('<a href="/#' + entry.boardSlug + '">' + entry.title + '</a> ');
			}
		}
		listElement.innerHTML = listHtml;
		divElement.classList.remove("hidden");
	} else {
		listElement.innerText = "";
		divElement.classList.add("hidden");
	}
};
refreshMyBoards(); // Show on initial homepage load

const clearMyBoards = function() {
	if (confirm("Are you sure? You will lose access to these boards if you have not saved their links elsewhere.")) {
		window.localStorage.clear();
		refreshMyBoards();
	}
};

const addMyBoard = function(boardSlug, title, expirationDateMs) {
	let myBoards = JSON.parse(window.localStorage.getItem(MY_BOARDS_LS_KEY) || "[]");
	let myBoardsNew = [];

	let shouldAdd = true;
	for (let i=0; i<myBoards.length; i++) {
		let entry = myBoards[i];
		if (entry.boardSlug === boardSlug) {
			shouldAdd = false;
		}
		if (entry.expirationDateMs > +new Date()) {
			myBoardsNew.push(entry);
		}
	}
	if (shouldAdd) {
		myBoardsNew.push({boardSlug, title, expirationDateMs});
	}
	
	window.localStorage.setItem(MY_BOARDS_LS_KEY, JSON.stringify(myBoardsNew));
}

const createBoard = function() {
	let title = document.getElementById("newBoardTitle").value.trim() || "(Untitled)";
	let description = document.getElementById("newBoardDescription").value.trim() || "(No description)";
	let lifespanDays = parseInt(document.getElementById("newBoardLifespan").value.trim());

	clearErrors();
	let anyErrors = false;
	if (title.length > 100) {
		document.getElementById("titleError").innerText = "Too long (" + title.length + " characters)";
		anyErrors = true;
	}
	if (description.length > 1000) {
		document.getElementById("descriptionError").innerText = "Too long (" + description.length + " characters)";
		anyErrors = true;
	}
	if (isNaN(lifespanDays)) {
		document.getElementById("lifespanError").innerText = "Must be a number"
		anyErrors = true;
	} else if (lifespanDays > 35) {
		document.getElementById("lifespanError").innerText = "Too large"
		anyErrors = true;
	}
	if (anyErrors) {
		return;
	}

	let secretKey = secureRandomString(SECRET_KEY_LENGTH);

	let button = document.getElementById("createBoardButton");
	button.disabled = true;

	let titleCtString = encrypt(secretKey, title);
	let descriptionCtString = encrypt(secretKey, description);

	httpPost("/api/create_board", {
		lifespan_days: lifespanDays,
		title_ct: titleCtString,
		description_ct: descriptionCtString
	}, function(response) {
		if (response.ok) {
			window.location.hash = secretKey + response.responseText;
		} else {
			alert("Error creating board! " + JSON.stringify(response));
		}
		button.disabled = null;
	});
};


const postReply = function() {
	let text = document.getElementById("replyText").value.trim();
	if (!text.length) {
		return;
	}
	if (text.length > 10000) {
		alert("Post is too long (>10000 characters)");
		return;
	}

	let splitHash = window.location.hash.slice(1).split("/");
	let boardSlug = splitHash[0];
	let lastPart = splitHash[1];
	let opId = lastPart.split("#")[0];

	let secretKey = boardSlug.substring(0, boardSlug.length-BOARD_CODE_LENGTH);
	let boardCode = boardSlug.substring(boardSlug.length-BOARD_CODE_LENGTH);


	let button = document.getElementById("postReplyButton");
	button.disabled = true;

	let textCt = encrypt(secretKey, text);

	httpPost("/api/create_post", {
		text_ct: textCt,
		board_code: boardCode,
		parent_post_id: opId
	}, function(response) {
		if (response.ok) {
			let currentHash = window.location.hash.slice(1);
			if (currentHash.indexOf("#") !== -1) {
				currentHash = currentHash.split("#")[0];
			}
			let newHash = currentHash + "#" + response.responseText;
			window.location.hash = newHash;
		} else {
			alert("Error creating post! " + JSON.stringify(response));
		}
		button.disabled = null;
	});
}


const renderText = function(original, postIdsOnPage, threadHash, mentionedPostsOutput) {
	let paragraphs = original.trim().split(/\n\n+/);
	let result = "";
	for (let i=0; i<paragraphs.length; i++) {
		let paragraph = paragraphs[i];
		let lines = paragraph.split("\n");
		result += "<p>";
		for (let j=0; j<lines.length; j++) {
			let line = lines[j].trim();
			let green = line.startsWith(">") && !line.startsWith(">>");
			let escapedLine = line
				.replace(/&/g, "&amp;")
				.replace(/</g, "&lt;")
				.replace(/>/g, "&gt;");

			let words = escapedLine.split(" ");
			let linkifiedLine = "";
			for (let k=0; k<words.length; k++) {
				let word = words[k];
				let wordSubstring = word.substring(8);
				let mentionedPost = parseInt(wordSubstring);
				if (postIdsOnPage &&
					word.startsWith("&gt;&gt;") &&
					!isNaN(mentionedPost) &&
					wordSubstring === ""+mentionedPost &&
					postIdsOnPage.indexOf(mentionedPost) !== -1) {
					linkifiedLine += (
						'<a href="/#' +
						threadHash + "#" + mentionedPost +
						'">' + word + '</a>'
					);
					if (mentionedPostsOutput.indexOf(mentionedPost) === -1) {
						mentionedPostsOutput.push(mentionedPost);
					}
				} else {
					linkifiedLine += word;
				}
				linkifiedLine += " ";
			}
			linkifiedLine = linkifiedLine.trim();

			if (green) {
				result += '<span class="greentext">';
			}
			result += linkifiedLine;
			if (green) {
				result += "</span>";
			}
			if (j<lines.length-1) {
				result += "<br/>";
			}
		}
		result += "</p>";
	}
	return result;
};


const clearForms = function() {
	document.getElementById("newThreadText").value = "";
	document.getElementById("newBoardTitle").value = "";
	document.getElementById("newBoardDescription").value = "";
	document.getElementById("newBoardLifespan").value = "";
	document.getElementById("replyText").value = "";
	clearErrors();
}

const clearErrors = function() {
	document.getElementById("titleError").innerText = "";
	document.getElementById("descriptionError").innerText = "";
	document.getElementById("lifespanError").innerText = "";
}

const PAGES = [
	"loadingPage",
	"badLinkPage",
	"incompleteLinkPage",
	"homePage",
	"boardPage",
	"threadPage"
];

const hideAllBut = function(pageToShow) {
	hideQR();
	stopCountdown();
	for (let i=0; i<PAGES.length; i++) {
		let page = PAGES[i];
		let element = document.getElementById(page);
		if (page === pageToShow) {
			element.classList.remove("hidden");
		} else {
			element.classList.add("hidden");
		}
	}
}


const formatTimestamp = function(timestampMs) {
	return new Date(timestampMs)
		.toISOString()
		.replace("T", " ").replace(/\.\d\d\dZ/, "");
}

const THREAD_ON_BOARD_TEMPLATE = 
`<div class="thread">
<div class="post">
<b>Anonymous</b> <a href="/#{{boardSlug}}/{{opId}}#{{opId}}">#{{opId}}</a> {{timestamp}}
{{renderedText}}
</div>
{{lastRepliesHtml}}
<a href="/#{{boardSlug}}/{{opId}}">Reply</a>
</div>`;

const POST_PREVIEW_TEMPLATE =
`<div class="post">
<b>Anonymous</b> <a href="/#{{boardSlug}}/{{opId}}#{{postId}}">#{{postId}}</a> {{timestamp}}
{{renderedText}}
</div>`;

const HIDDEN_REPLIES_TEMPLATE = `
<p>{{hiddenCount}} repl{{pluralEnding}} hidden; <a href="/#{{boardSlug}}/{{opId}}">view all</a></p>`;

const MS_PER_DAY = 1000*60*60*24;
const MS_PER_HOUR = 1000*60*60;
const MS_PER_MINUTE = 1000*60;
const MS_PER_SECOND = 1000;
const formatDuration = function(durationMs) {
	durationMs = Math.max(durationMs, 0);
	let days = Math.floor(durationMs / MS_PER_DAY);
	durationMs -= days*MS_PER_DAY;
	let hours = Math.floor(durationMs / MS_PER_HOUR);
	durationMs -= hours*MS_PER_HOUR;
	let minutes = Math.floor(durationMs / MS_PER_MINUTE);
	durationMs -= minutes*MS_PER_MINUTE;
	let seconds = Math.floor(durationMs / MS_PER_SECOND);
	if (days === 0 && hours === 0 && minutes < 10) {
		// When <10min, pad it out so it doesn't change size during the countdown
		return minutes + " minutes " + (seconds>=10 ? seconds : "0"+seconds) + " seconds" 
	} else {
		return ""
			+ (days ? days + " day" + (days === 1 ? "" : "s") + " " : "")
			+ (hours ? hours + " hour" + (hours === 1 ? "" : "s") + " " : "")
			+ (minutes ? minutes + " minute" + (minutes === 1 ? "" : "s") : "");
	}
};

let countdownInterval = void(0);

const startCountdown = function(element, countdownToMs) {
	if ("undefined" !== typeof(countdownInterval)) {
		clearInterval(countdownInterval);
	}
	countdownInterval = setInterval(function(){
		let duration = countdownToMs - new Date();
		element.innerText = formatDuration(duration);
		if (duration <= 0) {
			document.body.classList.add("fadeout");
			stopCountdown();
		}
	}, 1000);
}

const stopCountdown = function() {
	if ("undefined" !== typeof(countdownInterval)) {
		countdownInterval = clearInterval(countdownInterval);
	}
}

const showBoard = function(boardSlug, pageNum) {
	let secretKey = boardSlug.substring(0, boardSlug.length-BOARD_CODE_LENGTH);
	let boardCode = boardSlug.substring(boardSlug.length-BOARD_CODE_LENGTH);

	httpGet("/api/get_board?board_code=" +
			encodeURIComponent(boardCode) +
			(pageNum>1 ? "&page=" + pageNum : ""), function(response) {
		if (!response.ok) {
			if (response.status === 404) {
				showBadLink();
			} else {
				alert("Error getting board! " + JSON.stringify(response));
			}
			return;
		}
		let resObj = JSON.parse(response.responseText);
		let boardObj = resObj.board;
		let threads = resObj.threads;
		let pageCount = resObj.page_count;

		// Board info:
		let titleCt = boardObj.title_ct;
		let descriptionCt = boardObj.description_ct;
		let expirationDateMs = boardObj.expiration_date_ms;
		let title = decrypt(secretKey, titleCt);
		let description = decrypt(secretKey, descriptionCt);

		addMyBoard(boardSlug, title, expirationDateMs);

		document.getElementById("htmlTitle").innerText = title + " : Tempchan";
		document.getElementById("boardTitle").innerText = title;
		document.getElementById("boardDescription").innerHTML = renderText(description);
		document.getElementById("rssLink").href = "/api/rss?board=" + boardCode;

		let pagination = "";
		if (pageCount > 1) {
			pagination += "Page:";
			for (let i=1; i<=pageCount; i++) {
				if (i === pageNum) {
					pagination += ' <b>' + i + '</b>';
				} else {
					let pageLink = "/#" + boardSlug;
					if (i > 1) {
						pageLink += "/p/" + i;
					}
					pagination += ' <a href="' + pageLink + '">' + i + '</a>';
				}
			}
		}
		document.getElementById("paginationTop").innerHTML = pagination;
		document.getElementById("paginationBottom").innerHTML = pagination;

		// Thread listing:
		let threadsHtml = "";
		for (let i=0; i<threads.length; i++) {
			let thread = threads[i];
			let opText = renderText(decrypt(secretKey, thread.op.text_ct));
			let lastRepliesHtml = "";
			if (thread.op.replies_count) {
				let hiddenCount = thread.op.replies_count - thread.last_replies.length;
				if (hiddenCount) {
					lastRepliesHtml += HIDDEN_REPLIES_TEMPLATE
						.replaceAll("{{hiddenCount}}", hiddenCount)
						.replaceAll("{{pluralEnding}}", hiddenCount>1 ? "ies" : "y")
						.replaceAll("{{boardSlug}}", boardSlug)
						.replaceAll("{{opId}}", thread.op.post_id);
				}
				
				// Iterate backwards since the API returns them in reverse order
				for (let j=thread.last_replies.length-1; j>=0; j--) {
					let reply = thread.last_replies[j];
					let replyText = renderText(decrypt(secretKey, reply.text_ct));
					lastRepliesHtml += POST_PREVIEW_TEMPLATE
						.replaceAll("{{boardSlug}}", boardSlug)
						.replaceAll("{{opId}}", thread.op.post_id)
						.replaceAll("{{postId}}", reply.post_id)
						.replaceAll("{{timestamp}}", formatTimestamp(reply.timestamp_ms))
						.replaceAll("{{renderedText}}", replyText);
				}
			}
			let threadHtml = THREAD_ON_BOARD_TEMPLATE
				.replaceAll("{{boardSlug}}", boardSlug)
				.replaceAll("{{opId}}", thread.op.post_id)
				.replaceAll("{{timestamp}}", formatTimestamp(thread.op.timestamp_ms))
				.replaceAll("{{renderedText}}", opText)
				.replaceAll("{{lastRepliesHtml}}", lastRepliesHtml);
			threadsHtml += threadHtml;
		}
		document.getElementById("threadsView").innerHTML = threadsHtml;


		let timeTillDeletionMs = expirationDateMs - new Date();
		document.getElementById("boardDeletionCountdown").innerText = formatDuration(timeTillDeletionMs);
		document.getElementById("boardDeletionCountdown").title = formatTimestamp(expirationDateMs);

		clearForms();
		hideAllBut("boardPage");
		if (timeTillDeletionMs < 10*MS_PER_MINUTE) {
			startCountdown(document.getElementById("boardDeletionCountdown"), expirationDateMs);
		}
	});
};

const QR_DESIRED_SIZE = 145;
const QR_CELL_SIZE = 5;
const showQR = function() {
	let qrTable = QRCode.generateHTML(window.location.href);
	let actualSize = qrTable.getElementsByTagName("tr").length * QR_CELL_SIZE;
	let qrDiv = document.getElementById("qrCode");
	qrDiv.appendChild(qrTable);
	if (actualSize !== QR_DESIRED_SIZE) {
		let scale = QR_DESIRED_SIZE/actualSize;
		qrDiv.style.setProperty("transform", "scale(" + scale + ")");
	}
	document.getElementById("qrModalOuter").classList.remove("hidden");
};

const hideQR = function() {
	document.getElementById("qrCode").innerHTML = "";
	document.getElementById("qrModalOuter").classList.add("hidden");
};

const POST_ON_THREAD_TEMPLATE = `
<div class="post{{highlightStyle}}" id="post{{postId}}">
<b>Anonymous</b> <a href="/#{{boardSlug}}/{{opId}}#{{postId}}">#{{postId}}</a> <a href="" onclick="mention({{postId}}); return false" title="Mention this post">&lt;&lt;</a> {{timestamp}} {{backmentions}}
{{renderedText}}
</div>`;

const showThread = function(boardSlug, opId, highlitPost) {
	let secretKey = boardSlug.substring(0, boardSlug.length-BOARD_CODE_LENGTH);
	let boardCode = boardSlug.substring(boardSlug.length-BOARD_CODE_LENGTH);
	httpGet("/api/get_thread?board_code=" + encodeURIComponent(boardCode) + "&op_id=" + opId, function(response) {
		if (!response.ok) {
			if (response.status === 404) {
				showBadLink();
			} else {
				alert("Error getting thread! " + JSON.stringify(response));
			}
			return;
		}
		let res = JSON.parse(response.responseText);
		let posts = res.posts;
		if (!posts || posts[0].parent_post_id) {
			// Don't allow linking directly to a single reply
			showBadLink();
			return;
		}
		let board = res.board;
		let boardTitle = decrypt(secretKey, board.title_ct);
		let expirationDateMs = board.expiration_date_ms;
		addMyBoard(boardSlug, boardTitle, expirationDateMs);

		document.getElementById("htmlTitle").innerText =
			boardTitle + " | #" + opId + " : Tempchan";
		
		// First pass: Assemble the list of postIds
		let postIdsOnPage = [];
		let postIdToIndex = {};
		for (let i=0; i<posts.length; i++) {
			let post = posts[i];
			postIdsOnPage.push(post.post_id);
			postIdToIndex[post.post_id] = i;
		}

		// Second pass: Render the text, and get list of mentions in each post
		let renderedTexts = [];
		let mentionsInEachPost = [];
		let threadHash = boardSlug + "/" + opId;
		for (let i=0; i<posts.length; i++) {
			let post = posts[i];
			let mentionsInPost = [];
			let renderedText = renderText(
				decrypt(secretKey, post.text_ct),
				postIdsOnPage,
				threadHash,
				mentionsInPost
			);
			renderedTexts.push(renderedText);
			mentionsInEachPost.push(mentionsInPost);
		}

		// Third pass: Invert the post -> mentions mapping
		let mentionsOfEachPost = [];
		for (let i=0; i<posts.length; i++) {
			let mentions = mentionsInEachPost[i];
			for (let j=0; j<mentions.length; j++) {
				let mention = mentions[j];
				let index = postIdToIndex[mention];
				if (!mentionsOfEachPost[index]) {
					mentionsOfEachPost[index] = [];
				}
				mentionsOfEachPost[index].push(postIdsOnPage[i]);
			}
		}

		// Fourth and final pass: Assemble the HTML for the page
		let threadHtml = "";
		for (let i=0; i<posts.length; i++) {
			let post = posts[i];

			let mentionsOfThisPost = mentionsOfEachPost[i] || [];
			let backmentionsHtml = "";
			for (let j=0; j<mentionsOfThisPost.length; j++) {
				let mention = mentionsOfThisPost[j];
				backmentionsHtml += (
					'<a href="/#' +
					threadHash + 
					"#" +
					mention +
					'">&gt;&gt;' +
					mention +
					'</a> '
				);
			}
			
			let postHtml = POST_ON_THREAD_TEMPLATE
				.replaceAll("{{boardSlug}}", boardSlug)
				.replaceAll("{{opId}}", opId)
				.replaceAll("{{postId}}", post.post_id)
				.replaceAll("{{timestamp}}", formatTimestamp(post.timestamp_ms))
				.replaceAll("{{backmentions}}", backmentionsHtml)
				.replaceAll("{{renderedText}}", renderedTexts[i])
				.replaceAll("{{highlightStyle}}", highlitPost && parseInt(highlitPost) === post.post_id ? " highlit" : "");
			threadHtml += postHtml;
		}

		document.getElementById("fullThread").innerHTML = threadHtml;
		document.getElementById("threadBoardTitle").innerText = boardTitle;
		document.getElementById("threadBoardTitle").href = "/#" + boardSlug;
		document.getElementById("threadHeader").innerText = opId;

		let timeTillDeletionMs = expirationDateMs - new Date();
		document.getElementById("threadDeletionCountdown").innerText = formatDuration(timeTillDeletionMs);
		document.getElementById("threadDeletionCountdown").title = formatTimestamp(expirationDateMs);
		clearForms();
		hideAllBut("threadPage");
		if (timeTillDeletionMs < 10*MS_PER_MINUTE) {
			startCountdown(document.getElementById("threadDeletionCountdown"), expirationDateMs);
		}

		if (highlitPost) {
			document.getElementById("post" + parseInt(highlitPost)).scrollIntoView();
		}
	});
}

const mention = function(postId) {
	let replyTextField = document.getElementById("replyText");
	let replyTextValue = replyTextField.value;
	let spacer = "";
	if (replyTextValue && replyTextValue[replyTextValue.length-1].trim()) {
		// If it ends with non-whitespace, insert whitespace
		spacer = " ";
	}
	replyTextField.value = replyTextValue + spacer + ">>" + postId + " ";
	replyTextField.scrollIntoView();
}

const rescrollThread = function(boardSlug, opId, highlitPost) {
	let oldHighlitElement = document.getElementsByClassName("highlit")[0];
	if (oldHighlitElement) {
		oldHighlitElement.classList.remove("highlit");
	}
	if (highlitPost) {
		let element = document.getElementById("post" + highlitPost);
		if (element) {
			element.classList.add("highlit");
			element.scrollIntoView();
		} else {
			showLoading();
			showThread(boardSlug, opId, highlitPost);
		}

	} else {
		window.scrollTo(0,0);
	}
}

const showBadLink = function() {
	document.getElementById("htmlTitle").innerText = "Tempchan : not found";
	hideAllBut("badLinkPage");
}

const showIncompleteLink = function() {
	document.getElementById("htmlTitle").innerText = "Tempchan : incomplete link";
	hideAllBut("incompleteLinkPage");
}

const showLoading = function() {
	hideAllBut("loadingPage");
}

const showHome = function() {
	clearForms();
	document.getElementById("htmlTitle").innerText = "Tempchan : throwaway discussion boards";
	refreshMyBoards();
	hideAllBut("homePage");
}


const newThread = function() {
	let text = document.getElementById("newThreadText").value.trim();
	if (!text.length) {
		return;
	}
	if (text.length > 10000) {
		alert("Post is too long (>10000 characters)");
		return;
	}

	// Fix this to work with other hash types
	let boardSlug = window.location.hash.slice(1);
	let secretKey = boardSlug.substring(0, boardSlug.length-BOARD_CODE_LENGTH);
	let boardCode = boardSlug.substring(boardSlug.length-BOARD_CODE_LENGTH);

	let button = document.getElementById("newThreadButton");
	button.disabled = true;

	let textCtString = encrypt(secretKey, text);

	httpPost("/api/create_post", {
		text_ct: textCtString,
		board_code: boardCode
	}, function(response) {
		if (response.ok) {
			let newHash = boardSlug + "/" + response.responseText;
			window.location.hash = newHash;
		} else {
			alert("Error creating post! " + JSON.stringify(res));
		}
		button.disabled = null;
	});
}

const findBoardSlug = function(boardCode) {
	let myBoards = JSON.parse(window.localStorage.getItem(MY_BOARDS_LS_KEY) || "[]");
	for (let i=0; i<myBoards.length; i++) {
		let entry = myBoards[i];
		if (entry.boardSlug.endsWith(boardCode)) {
			return entry.boardSlug;
		}
	}
	return false;
};


const handleHash = function(oldHash) {
	if (window.location.hash) {
		let newHash = window.location.hash.slice(1);
		let splitHash = newHash.split("/");
		if (splitHash[0].length === BOARD_CODE_LENGTH) {
			let boardSlugFromHistory = findBoardSlug(splitHash[0]);
			if (boardSlugFromHistory) {
				// Redirect:
				splitHash[0] = boardSlugFromHistory;
				let redirectToHash = splitHash.join("/");
				window.location.replace("#"+redirectToHash);
			} else {
				showIncompleteLink();
			}
		} else if (splitHash[0].length === SECRET_KEY_LENGTH + BOARD_CODE_LENGTH) {
			let boardSlug = splitHash[0];
			if (splitHash.length === 1) {
				showLoading();
				showBoard(boardSlug, 1);
			} else if (splitHash.length === 2) {
				let lastPart = splitHash[1];
				let opId;
				let highlitPost = void(0);
				if (lastPart.indexOf("#") !== -1) {
					let lastPartSplit = lastPart.split("#");
					opId = lastPartSplit[0];
					highlitPost = lastPartSplit[1];
				} else {
					opId = lastPart;
				}

				let oldHashPrefix = oldHash && oldHash.split("#")[0];

				if (oldHashPrefix && (
					newHash === oldHashPrefix ||
					newHash.startsWith(oldHashPrefix+"#"))
				) {
					rescrollThread(boardSlug, opId, highlitPost);
				} else {
					showLoading();
					showThread(boardSlug, opId, highlitPost);
				}
			} else if (splitHash.length === 3 && splitHash[1] === "p") {
				showLoading();
				let pageNum = parseInt(splitHash[2]);
				if (pageNum) {
					if (pageNum === 1) {
						// Redirect:
						window.location.replace("#"+boardSlug);
					} else {
						showBoard(boardSlug, pageNum);
					}
				} else {
					showBadLink();
				}
			} else {
				showBadLink();
			}
		} else {
			showBadLink();
		}
	} else {
		showHome();
	}
};

window.onload = function() {
	handleHash();
};

window.onhashchange = function(event) {
	let oldURL = event.oldURL;
	let index = oldURL.indexOf("#");
	let oldHash = "";
	if (index !== -1) {
		oldHash = oldURL.slice(1+index);
	}
	handleHash(oldHash);
};

</script>
</body>
</html>
